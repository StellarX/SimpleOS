# 23.4
- 强制结束并且关闭窗口（以前并没有关闭窗口）
# 23.3
- 在绘制散点完成后再统一刷新窗口，加快速度
- （编写）画直线（的应用程序和API以及处理程序）
- 编写键盘输入API、关闭窗口API，实现按下回车再关闭窗口
- 利用这些API编写一个让'*'在窗口中受控移动的应用程序
# 23.2
- 编写绘制随机散点的API
# 23.1
- 编写为应用程序分配内存的malloc(API)
# 22.1
- 继续用crack程序测试异常，保护OS
- 利用CPU的异常处理功能发现bug
- 在harimain中添加强制结束应用程序的代码
- 编写显示字符串的API，然后用c调用
- 编写显示窗口的API
- 编写在窗口上显示字符和描绘方块的API
# 21.2
- 将应用程序栈和系统栈分开，保护操作系统，并且编写crack程序测试
- 支持一般保护异常
- 在段定义处加上访问权限
# 21.1
- 解决昨天hello2字符串显示的异常。
原因是显示字符串无法指定代码段（CS）地址，程序误以为是DS段，所以从错误的地址读取了内容。
解决办法：将CS的基址直接告诉hrb_api（通过存入内存再读取）
- 开始用C语言编写应用程序（包括一些必要的准备工作）

# 20.3
- 将API注册到IDT，实现不随OS版本改变而改变的API；
- 添加显示字符串的API，同时借鉴BIOS的调用方式，使用功能号区别API

# 20.2
- 在hlt.nas应用程序中执行系统调用，调用操作系统的cons_putchar函数，显示一个字符。
具体过程：
1. （far）call API  ：_asm_cons_putchar。这个汇编函数将系统调用所需的参数push入栈，
这样cons_putchar才能接收参数（far call 是因为应用程序和OS不在同一个段内）
2. 准备好参数后，_asm_cons_putchar将会call cons_putchar
3. 最后_asm_cons_putchar RETF，相当于far return，返回应用程序
 _asm_cons_putchar也属于OS，它是OS对应用程序提供的接口程序

- 实现应用程序的结束。只需在应用程序里加入RETF，_asm_cons_putchar 的RET改为RETF，
操作系统里的hlt命令处理里面将farjump改为farcall

# 20.1
- 整理console.c、file.c文件

# 19.3
- 运行第一个应用程序hlt.nas。
简述过程：
首先用nask将其编译为.hrb文件（这里没有命名为.exe是为了防止和windows的可执行未见产生混淆）；
在命令行输入hlt；
程序会找到该文件；
然后从磁盘载入到内存的一个段，将该段注册到GDT；
然后跳转到该段，也就是开始运行

# 19.2
- type命令改进：处理文件中的换行符、制表符；
- 在type命令中加入对FAT的支持；
- 整理bootpack.c，创建window.c file.c console.c

> 按照Windows管理磁盘的方法，保存大于512字节的文件时，有时候并不是存入连续的扇区中。
> 现在的type命令可以正确显示文件开头的512个字节的内容，但是大于512个字节的文件，
> 中间可能就会突然显示出其他文件的内容。
> 对于文件的下一段存放在哪里，在磁盘中是有记录的，
> 这个记录被称为file allocation table（即记录文件在磁盘中存放位置的表）。

# 19.1
- 支持type命令读文件

# 18.2
- 在命令行窗口实现mem、cls等命令
- 实现dir命令

# 18.1
- 控制光标闪烁，即只让当前窗口的光标闪烁；
- 支持回车换行

# 17.2
- 支持符号键的输入
- 支持小写字母输入
- 支持各种锁定键，从键盘控制器取得led灯状态

# 17.1
- 创建一个闲置任务，防止没有任务时程序异常；
- 创建命令行窗口任务；
- 实现切换输入窗口：将make_window8中描绘窗口标题栏的代码，和描绘窗口剩余部分的代码区分开来；
- 实现字符切换不同窗口输入

# 16.4
- 设定任务优先级，通过改变不同任务的切换间隔来实现；
- 添加层级架构。
> 这种架构的工作原理是，
> 最上层的LEVEL 0中只要存在哪怕一个任务，则完全忽略LEVEL 1和LEVEL 2中的任务，
> 只在LEVEL 0的任务中进行任务切换。当LEVEL 0中的任务全部休眠，或者全部降到下层LEVEL，
> 也就是当LEVEL 0中没有任何任务的时候，接下来开始轮到LEVEL 1中的任务进行任务切换。
> 当LEVEL 0和LEVEL 1中都没有任务时，那就该轮到LEVEL 2出场了

# 16.3
- 增加窗口/任务数量，每个窗口分别属于一个任务
（这里并没有创建其他任务的处理函数，而是利用循环“拷贝”了一份原来的b任务的处理函数，
参考bootpack第60行的循环程序）

# 16.2
- 实现让空闲的任务休眠。简单的思路是这样的：
当缓冲区没有数据时，让任务休眠；
有数据时会产生中断，中断处理函数会执行写入缓冲区函数，所以在写入缓冲区函数里再唤醒对应的任务

# 16.1
- 创建多任务管理结构；
- 编写通用的初始化、分配、运行、切换等函数

# 15.3
- 实现真正的多任务，把负责任务切换的主体程序放入mtask中。
> 之前都是依靠在HariMain和task_b_main中写入负责任务切换的代码来实现的。
> 如果任务B因为发生bug而无法进行切换，那么当切换到任务B以后，其他的任务就再也无法运行了，这样会造成无论是按键盘还是动鼠标都毫无反应的悲剧。
> 真正的多任务，是要做到在该任务程序本身不知道的情况下进行任务切换。

# 15.2
- 多任务进阶：
- 实现切换回A任务；
- 在naskfunc里编写farjmp，实现更便捷的任务切换；
- 在任务B里添加计数并显示的程序

# 15.1
- 多任务初步实现

# 14.4
- 实现窗口移动
- 只用两行代码就实现了窗口的移动，这么容易是因为之前在图层叠加处理所下的功夫！！！

# 14.3
- 实现显示按键字母：按键产生中断后，会发送两个字节，我们只用第一个字节区别按键；
- 实现在窗口连续输入字符/删除字符！

# 14.2
- 在asmhead中完善画面模式切换前的检查工作

# 14.1
- 启用VBE高分辨率新画面模式

# 13.4
- 使用哨兵简化timer_settime函数和定时器中断处理

# 13.3
- 加快定时器中断处理，使用链式结构来管理定时器，加快增、删的速度（之前是移动）

# 13.2
- 把键盘、鼠标、定时器的缓冲全部合并在一起，用一个data变量区别缓冲区数据是哪个设备的（简单的说）。
程序更快了，因为这次修改以后程序只需要看1个FIFO缓冲区就行了，而以前要看3个。
也就是说，FIFO缓冲区的查询能够更快完成

# 13.1
- 将字符串显示的几个函数合并；
- 将定时器的缓冲区合并，用超时时长区别数据；
- 测试了一下性能

# 12.2
- 加快中断处理1、加快中断处理2
> 这些改进的具体内容很容易理解，却很难想到，总之这些小小的改进，虽然肉眼很难看到速度的提升，
> 但累计的效果在最后一定会很明显，操作系统就是这样不断修复缺陷，想办法减少程序不必要的语句（主要是循环），
> 提升处理速度而成长起来的，当然，这样的话，程序就会变得更复杂

- 加快中断处理3
借鉴图层处理的方法，将各个定时器按照到时的时刻排序，
用using存储在使用状态的定时器数量，不用进行flag判断了

# 12.1
- 设定中断周期为0x2e9c（11932），对应中断频率为100Hz，也就是1s产生100次中断；
- 添加timer.c，存放定时器管理程序（初始化、分配、释放等）；
- 编写定时器管理结构体，分配3个定时器，分别是10s、3s以及模拟光标闪烁的定时器

# 11.2
- 制作一个计数器窗口；
- 解决一些棘手的图层显示问题

# 11.1
- 绘制一个窗口图层

# 10.3
- 提高叠加处理速度（2）

# 10.2
- 提高叠加处理速度（1）

# 10.1
- 把内存管理的代码放入memory.c中
- 同时编写以0x1000为单位进行内存分配和释放的函数（之前是以1字节为单位）
 
- 创建一个管理多重图层信息的结构
- 添加sheet.c文件：存放图层处理的代码
- 创建桌面和鼠标两个图层，解决8.1遗留的问题

# 9.3
- 建立内存管理表；
- 添加内存分配、释放函数

# 9.2
- 内存容量检查

# 9.1
- 整理源代码：添加keyboard.c、mouse.c

# 8.1
- 鼠标数据的解读1（把接收到的数据分为3字节显示）；
- 鼠标数据的解读2（更加细致：分为按键状态和移动信息）；
- 根据接收到的数据移动鼠标，移到下方任务栏时会擦除掉任务栏（存在问题）

# 7.3
- 对键盘控制电路进行一些设定后，激活鼠标；
- 创建鼠标缓冲区；
- 修改鼠标中断处理程序；
- 开始从鼠标接收数据，显示到屏幕

# 7.2
- 添加fifo.c文件，编写可变长循环队列缓冲区，用于接收按键编码

# 7.1
- 获取按键编码；
- 将中断处理程序中的绘制图像的程序移出，加快中断处理
- 将接收的按键编码存入缓冲变量

# 6.3
- 编写鼠标和键盘的中断处理程序（并注册到IDT表），具体执行过程：
1. 	首先在naskfunc中执行用汇编写的中断现场保护的程序（asm_inthandler21），
2. 	然后用call指令跳转到int.c中执行中断处理程序（void inthandler21(int *esp)），
3. 	最后返回naskfunc执行恢复现场以及中断返回（IRETD）的程序
（注意：IDT表中注册的是naskfunc中汇编程序的起始地址）
4. 最后解除鼠标、键盘的中断屏蔽位

# 6.2
- 添加int.c文件，用于初始化中断控制器PIC

# 6.1
- 添加头文件，分割编译

# 5.4
- 全局段号记录表GDT和中断记录表IDT初始化

# 5.3
- 显示变量的值和鼠标指针到屏幕

# 5.2
- 使用OSASK的字体数据hankaku.txt，将其编译为obj文件后和bootpack.obj链接；
- 添加绘制字符串的函数

# 5.1
- 使用结构体简化代码；
- 显示字符A

# 4.3 
- 绘制任务栏

# 4.2
- 处理了颜色问题（使用调色板方式）；
- 绘制矩形

# 4.1 
- 往显存写入数据

# 3.5 
- 添加naskfunc.nas文件，存放用汇编写的函数，编译后与bootpack.obj链接；
- 在bootpack里引用naskfunc.nas中的函数

# 3.4 
- 删除haribote.nas ，分解为asmhead.nas和bootpack.c；
- 32位模式前期准备（从BIOS得到键盘状态、保存当前画面模式到内存 etc.）；
- 设置显卡内存；
- 开始导入C语言；
- makefile文件里添加了相关文件生成规则

# 3.3
- 在haribote.nas中添加设定画面模式的代码；
- 在ipl执行完后，OS被装载到了内存，所以JMP到haribote在内存中的位置，执行OS
- ipl文件名改为ipl10（10个柱面）

# 3.2
- 读盘程序/启动程序加载器已经制作完成，开始着手开发操作系统；
- 添加haribote.nas文件(os目前就存放于此)，将其编译为sys文件，并保存到img文件（借助edimg.exe）