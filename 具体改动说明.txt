15.1
多任务初步实现

14.4
实现窗口移动
只用两行代码就实现了窗口的移动，这么容易是因为之前在图层叠加处理所下的功夫！！！

14.3
实现显示按键字母：按键产生中断后，会发送两个字节，我们只用第一个字节区别按键；
实现在窗口连续输入字符/删除字符！

14.2
在asmhead中完善画面模式切换前的检查工作

14.1
启用VBE高分辨率新画面模式

13.4
使用哨兵简化timer_settime函数和定时器中断处理

13.3
加快定时器中断处理，使用链式结构来管理定时器，加快增、删的速度（之前是移动）

13.2
把键盘、鼠标、定时器的缓冲全部合并在一起，
用一个data变量区别缓冲区数据是哪个设备的（简单的说）。
程序更快了，因为这次修改以后程序只需要看1个FIFO缓冲区就行了，而以前要看3个。
也就是说，FIFO缓冲区的查询能够更快完成

13.1
将字符串显示的几个函数合并；
将定时器的缓冲区合并，用超时时长区别数据；
测试了一下性能

12.2
加快中断处理1、加快中断处理2
这些改进的具体内容很容易理解，却很难想到，总之这些小小的改进，虽然肉眼很难看到速度的提升，
但累计的效果在最后一定会很明显，操作系统就是这样不断修复缺陷，想办法减少程序不必要的语句（主要是循环），
提升处理速度而成长起来的，当然，这样的话，程序就会变得更复杂

加快中断处理3
借鉴图层处理的方法，将各个定时器按照到时的时刻排序，
用using存储在使用状态的定时器数量，不用进行flag判断了

12.1
设定中断周期为0x2e9c（11932），对应中断频率为100Hz，也就是1s产生100次中断；
添加timer.c，存放定时器管理程序（初始化、分配、释放等）；
编写定时器管理结构体，分配3个定时器，分别是10s、3s以及模拟光标闪烁的定时器

11.2
制作一个计数器窗口；
解决一些棘手的图层显示问题

11.1
绘制一个窗口图层

10.3
提高叠加处理速度（2）

10.2
提高叠加处理速度（1）

10.1
把内存管理的代码放入memory.c中
同时编写以0x1000为单位进行内存分配和释放的函数（之前是以1字节为单位）
 
创建一个管理多重图层信息的结构
添加sheet.c文件：存放图层处理的代码
创建桌面和鼠标两个图层，解决8.1遗留的问题

9.3
建立内存管理表；
添加内存分配、释放函数

9.2
内存容量检查

9.1
整理源代码：添加keyboard.c、mouse.c

8.1
鼠标数据的解读1（把接收到的数据分为3字节显示）；
鼠标数据的解读2（更加细致：分为按键状态和移动信息）；
根据接收到的数据移动鼠标，移到下方任务栏时会擦除掉任务栏（存在问题）

7.3
对键盘控制电路进行一些设定后，激活鼠标；
创建鼠标缓冲区；
修改鼠标中断处理程序；
开始从鼠标接收数据，显示到屏幕

7.2
添加fifo.c文件，编写可变长循环队列缓冲区，用于接收按键编码

7.1
获取按键编码；
将中断处理程序中的绘制图像的程序移出，加快中断处理
将接收的按键编码存入缓冲变量

6.3
编写鼠标和键盘的中断处理程序（并注册到IDT表），具体执行过程：
	首先在naskfunc中执行用汇编写的中断现场保护的程序（asm_inthandler21），
	然后用call指令跳转到int.c中执行中断处理程序（void inthandler21(int *esp)），
	最后返回naskfunc执行恢复现场以及中断返回（IRETD）的程序
（注意：IDT表中注册的是naskfunc中汇编程序的起始地址）
最后解除鼠标、键盘的中断屏蔽位

6.2
添加int.c文件，用于初始化中断控制器PIC

6.1
添加头文件，分割编译

5.4
全局段号记录表GDT和中断记录表IDT初始化

5.3
显示变量的值和鼠标指针到屏幕

5.2
使用OSASK的字体数据hankaku.txt，将其编译为obj文件后和bootpack.obj链接；
添加绘制字符串的函数

5.1
使用结构体简化代码；
显示字符A

4.3 
绘制任务栏

4.2
处理了颜色问题（使用调色板方式）；
绘制矩形

4.1 
往显存写入数据

3.5 
添加naskfunc.nas文件，存放用汇编写的函数，编译后与bootpack.obj链接；
在bootpack里引用naskfunc.nas中的函数

3.4 
删除haribote.nas ，分解为asmhead.nas和bootpack.c；
32位模式前期准备（从BIOS得到键盘状态、保存当前画面模式到内存 etc.）；
设置显卡内存；
开始导入C语言；
makefile文件里添加了相关文件生成规则

3.3
在haribote.nas中添加设定画面模式的代码；
在ipl执行完后，OS被装载到了内存，所以JMP到haribote在内存中的位置，执行OS
ipl文件名改为ipl10（10个柱面）

3.2
读盘程序/启动程序加载器已经制作完成，开始着手开发操作系统；
添加haribote.nas文件(os目前就存放于此)，将其编译为sys文件，并保存到img文件（借助edimg.exe）