19.1
支持type命令读文件

18.2
在命令行窗口实现mem、cls等命令
实现dir命令

18.1
控制光标闪烁，即只让当前窗口的光标闪烁；
支持回车换行

17.2
支持符号键的输入
支持小写字母输入
支持各种锁定键，从键盘控制器取得led灯状态

17.1
创建一个闲置任务，防止没有任务时程序异常；
创建命令行窗口任务；
实现切换输入窗口：将make_window8中描绘窗口标题栏的代码，和描绘窗口剩余部分的代码区分开来；
实现字符切换不同窗口输入

16.4
设定任务优先级，通过改变不同任务的切换间隔来实现；

添加层级架构。这种架构的工作原理是，
最上层的LEVEL 0中只要存在哪怕一个任务，则完全忽略LEVEL 1和LEVEL 2中的任务，
只在LEVEL 0的任务中进行任务切换。当LEVEL 0中的任务全部休眠，或者全部降到下层LEVEL，
也就是当LEVEL 0中没有任何任务的时候，接下来开始轮到LEVEL 1中的任务进行任务切换。
当LEVEL 0和LEVEL 1中都没有任务时，那就该轮到LEVEL 2出场了

16.3
增加窗口/任务数量，每个窗口分别属于一个任务
（这里并没有创建其他任务的处理函数，而是利用循环“拷贝”了一份原来的b任务的处理函数，
参考bootpack第60行的循环程序）

16.2
实现让空闲的任务休眠。
简单的思路是这样的：
当缓冲区没有数据时，让任务休眠；
有数据时会产生中断，中断处理函数会执行写入缓冲区函数，所以在写入缓冲区函数里再唤醒对应的任务

16.1
创建多任务管理结构；
编写通用的初始化、分配、运行、切换等函数

15.3
实现真正的多任务，把负责任务切换的主体程序放入mtask中。
之前都是依靠在HariMain和task_b_main中写入负责任务切换的代码来实现的。
如果任务B因为发生bug而无法进行切换，那么当切换到任务B以后，其他的任务就再也无法运行了，这样会造成无论是按键盘还是动鼠标都毫无反应的悲剧。
真正的多任务，是要做到在该任务程序本身不知道的情况下进行任务切换。

15.2
多任务进阶：
实现切换回A任务；
在naskfunc里编写farjmp，实现更便捷的任务切换；
在任务B里添加计数并显示的程序

15.1
多任务初步实现

14.4
实现窗口移动
只用两行代码就实现了窗口的移动，这么容易是因为之前在图层叠加处理所下的功夫！！！

14.3
实现显示按键字母：按键产生中断后，会发送两个字节，我们只用第一个字节区别按键；
实现在窗口连续输入字符/删除字符！

14.2
在asmhead中完善画面模式切换前的检查工作

14.1
启用VBE高分辨率新画面模式

13.4
使用哨兵简化timer_settime函数和定时器中断处理

13.3
加快定时器中断处理，使用链式结构来管理定时器，加快增、删的速度（之前是移动）

13.2
把键盘、鼠标、定时器的缓冲全部合并在一起，
用一个data变量区别缓冲区数据是哪个设备的（简单的说）。
程序更快了，因为这次修改以后程序只需要看1个FIFO缓冲区就行了，而以前要看3个。
也就是说，FIFO缓冲区的查询能够更快完成

13.1
将字符串显示的几个函数合并；
将定时器的缓冲区合并，用超时时长区别数据；
测试了一下性能

12.2
加快中断处理1、加快中断处理2
这些改进的具体内容很容易理解，却很难想到，总之这些小小的改进，虽然肉眼很难看到速度的提升，
但累计的效果在最后一定会很明显，操作系统就是这样不断修复缺陷，想办法减少程序不必要的语句（主要是循环），
提升处理速度而成长起来的，当然，这样的话，程序就会变得更复杂

加快中断处理3
借鉴图层处理的方法，将各个定时器按照到时的时刻排序，
用using存储在使用状态的定时器数量，不用进行flag判断了

12.1
设定中断周期为0x2e9c（11932），对应中断频率为100Hz，也就是1s产生100次中断；
添加timer.c，存放定时器管理程序（初始化、分配、释放等）；
编写定时器管理结构体，分配3个定时器，分别是10s、3s以及模拟光标闪烁的定时器

11.2
制作一个计数器窗口；
解决一些棘手的图层显示问题

11.1
绘制一个窗口图层

10.3
提高叠加处理速度（2）

10.2
提高叠加处理速度（1）

10.1
把内存管理的代码放入memory.c中
同时编写以0x1000为单位进行内存分配和释放的函数（之前是以1字节为单位）
 
创建一个管理多重图层信息的结构
添加sheet.c文件：存放图层处理的代码
创建桌面和鼠标两个图层，解决8.1遗留的问题

9.3
建立内存管理表；
添加内存分配、释放函数

9.2
内存容量检查

9.1
整理源代码：添加keyboard.c、mouse.c

8.1
鼠标数据的解读1（把接收到的数据分为3字节显示）；
鼠标数据的解读2（更加细致：分为按键状态和移动信息）；
根据接收到的数据移动鼠标，移到下方任务栏时会擦除掉任务栏（存在问题）

7.3
对键盘控制电路进行一些设定后，激活鼠标；
创建鼠标缓冲区；
修改鼠标中断处理程序；
开始从鼠标接收数据，显示到屏幕

7.2
添加fifo.c文件，编写可变长循环队列缓冲区，用于接收按键编码

7.1
获取按键编码；
将中断处理程序中的绘制图像的程序移出，加快中断处理
将接收的按键编码存入缓冲变量

6.3
编写鼠标和键盘的中断处理程序（并注册到IDT表），具体执行过程：
	首先在naskfunc中执行用汇编写的中断现场保护的程序（asm_inthandler21），
	然后用call指令跳转到int.c中执行中断处理程序（void inthandler21(int *esp)），
	最后返回naskfunc执行恢复现场以及中断返回（IRETD）的程序
（注意：IDT表中注册的是naskfunc中汇编程序的起始地址）
最后解除鼠标、键盘的中断屏蔽位

6.2
添加int.c文件，用于初始化中断控制器PIC

6.1
添加头文件，分割编译

5.4
全局段号记录表GDT和中断记录表IDT初始化

5.3
显示变量的值和鼠标指针到屏幕

5.2
使用OSASK的字体数据hankaku.txt，将其编译为obj文件后和bootpack.obj链接；
添加绘制字符串的函数

5.1
使用结构体简化代码；
显示字符A

4.3 
绘制任务栏

4.2
处理了颜色问题（使用调色板方式）；
绘制矩形

4.1 
往显存写入数据

3.5 
添加naskfunc.nas文件，存放用汇编写的函数，编译后与bootpack.obj链接；
在bootpack里引用naskfunc.nas中的函数

3.4 
删除haribote.nas ，分解为asmhead.nas和bootpack.c；
32位模式前期准备（从BIOS得到键盘状态、保存当前画面模式到内存 etc.）；
设置显卡内存；
开始导入C语言；
makefile文件里添加了相关文件生成规则

3.3
在haribote.nas中添加设定画面模式的代码；
在ipl执行完后，OS被装载到了内存，所以JMP到haribote在内存中的位置，执行OS
ipl文件名改为ipl10（10个柱面）

3.2
读盘程序/启动程序加载器已经制作完成，开始着手开发操作系统；
添加haribote.nas文件(os目前就存放于此)，将其编译为sys文件，并保存到img文件（借助edimg.exe）